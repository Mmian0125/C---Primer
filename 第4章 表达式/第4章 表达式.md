# 第4章 表达式

## 4.1 基础

函数调用也是一种特殊的运算符。

### 4.1.1 基本概念

**运算对象转化**：小整数类型（如：bool，char，short等）通常会被提升成较大的整数类型。

**左值和右值**：左值表示一个占据内存中某个可识别位置（地址）的对象。右值即非左值，是一个不表示内存中可识别位置对象的表达式。

需要右值的地方可以用左值来替代（实际上使用的是它的值），但不能将右值当成左值使用。

存在几种熟悉的运算符要用到左值：赋值运算符需要一个左值作为左侧运算对象，得到的结果也是一个左值；取地址符作用于一个左值运算对象，返回一个指向该运算符对象的指针，该指针是一个右值；内置解引用运算符、下标运算符迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值；内置类型和迭代器的递增递减运算符作用域左值运算对象，所得的结果也是左值。

使用关键字decltype的时候，左值和右值也不同。若表达式的求职结果是左值，decltype作用于该表达式得到一个引用类型。如：p的类型是int*，因为解引用运算符生成左值，所以decltype(*p)的结果是int&。另一方面，因为取地址运算符生成右值，所以decltype(&p)的结果是int**，即结果是一个指向整型指针的指针。？？？？

### 4.1.2 优先级与结合律

### 4.1.3 求值顺序

优先级规定了运算对象的组合方式，但没有说明运算对象按照什么顺序求值。在大多情况下，不会明确指定求值的顺序，如：`int i=f1()*f2()`无法确定是f1在f2前调用还是f2在f1前调用。

对于那些没有指定执行顺序的运算符来说，若表达式指向并修改了同一对象，将引发错误并产生未定义的行为，如：<<运算符没有明确规定何时以及如何对运算对象求值，因此下面的输出表达式是未定义的：

```python
int i=0;
cout<<i<<" "<<i++<<endl;
```

但是有4种运算符规定了运算对象的求值顺序：逻辑与运算符（规定先求左侧运算对象的值，只有当左侧对象的值为真时才继续求右侧运算对象的值），逻辑或运算符，条件运算符，逗号运算符。

**求值顺序、优先级、结合律**：运算对象的求值顺序和优先级与结合律无关，如在形如`f()+g()*h()+j()`的表达式中，若f，g，h，j是无关函数，且它们即不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，若其中某几个函数影响同一对象，则它是一条错误的表达式，且会产生未定义的行为。

> 处理复合表达式的建议：1.拿不准时最好用括号让表达式的组合关系复合程序逻辑。2.若改变了某个运算符对象的值，在表达式的其他地方最好不要再使用这个运算对象。但有例外，当表达式运算对象的子表达式本身就是另外一个子表达式的运算对象时规则无效。如，在表达式`*++iter`中，求值不会称为问题。
> 

## 4.2 算数运算符

| + | 一元正号 |
| --- | --- |
| - | 一元负号 |
| * | 乘法 |
| / | 除法 |
| % | 取余 |
| + | 加法 |
| - | 减法 |

优先级从上到下依次递减。一元运算符的优先级最高，接下来是乘法和除法，优先级最低的是加法和减法。上述所有运算符都满足左结合律。

一元正号运算符、加法运算符和减法运算符都能作用域指针。当一元正号运算符作用于一个指针或者算数值时，返回运算对象值的一个（提升后的）副本。一元符号运算符对运算值取负后，返回一个（提升后的）副本。

```python
int i=1024;
int k=-i;  //k=-1024
bool b=true;
bool a=-b;  //a为true
//大多情况下，布尔类型不参与运算
//该例中，布尔类型被提升为int类型，参与运算时被提升为整数值1，求负后结果为-1
//再将-1转换为布尔类型，结果非0，为true。
```

> 溢出和其他算数运算异常：算数表达式可能产生未定义的结果，一部分由于数学性质本身，如：除数为0，另一部分由于计算机的特点，如：溢出，当计算的结果超出该类型所能表示范围的时产生溢出。
> 

参与取余运算的运算对象必须是整数：

```python
int ival=42;
double dval=3.14;
ival%12;  //正确
dval%12;  //错误
```

除了-m导致溢出的情况，其他时候(-m) / n和m / (-n)都等于-(m / n)，m%(-n)等于m%n，(-m)%n等于-(m%n)

## 4.3 逻辑和关系运算符

| ! | 非 |
| --- | --- |
| < | 小于 |
| ≤ | 小于等于 |
| > | 大于 |
| ≥ | 大于等于 |
| == | 相等 |
| ≠ | 不相等 |
| && | 逻辑与 |
| || | 逻辑或 |

优先级从上到下依次递减。

**逻辑与和逻辑或运算符**：

短路求值：对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值；对于逻辑或运算符来说，当且仅当左侧运算符为假时才对右侧运算对象求值。

```python
//输出string对象的内容且在遇到空字符或者以句号结尾的字符串时进行换行。
for(const auto &s : text){
	cout<<s;
	if(s.empty() || s[s.size()-1]=='.')
		cout<<endl;
	else
		cout<<" ";
}
/*注意s被声明为了对于常量的引用，因为text对象可能是string对象，声明为引用类型
可以避免对元素的拷贝，且因为不需要对string对象进行写操作，所以被声明为常量的引
用*/
```

**相等性测试与布尔字面值**：

```python
if(val) /*...*/  //若val为任意非0值，条件为真
if(!val) /*...*/  //若val为0值时，条件为真
```

进行比较运算时除非比较对象是布尔类型，否则不要使用布尔字面值false，true作为运算对象

## 4.4 赋值运算符

赋值运算符的左侧对象必须是一个可修改的左值；

```python
int i=0,j=0,k=0;
const int ci=i;
//若给定上述语句，则以下语句是非法的
1024=k;  //字面值为右值
i+j=k;  //算数表达式为右值
ci=k;  //ci为不可修改的左值
```

C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧对象：

```python
k={3.14};  //错误：缩窄转换
vector<int> vi;  //初始化为空
vi={1,2,3};  //将三个值赋给vector
```

若左侧运算对象为内置类型，则初始值列表最多包含一个值，且该值即使转换其所占空间也不应大于目标类型的空间。而左侧运算对象为类类型来说，赋值细节由类本身决定，如对于vector来说，vector模板重载了赋值运算符并可以接收初始值列表。

不论左侧运算对象是什么，初始值列表都可以为空，此时编译器创建一个初始化的临时量并赋给左侧的对象。

**赋值运算满座右结合律**：

```python
int ival,jval;
ival=jval=0;

int ival,*pval;
ival=pval=0;  //错误，(pval)int*类型无法转换成int(ival),所以即使0可以赋给
任何对象，该语句仍然是非法的。
```

**赋值运算符的优先级低**：

```python
int i;
while( (i=get_value()) != 42 ){
	...
}
```

因为赋值运算符的优先级低于关系运算符，所以在条件运算语句中，赋值部分应该加上括号。

## 4.5 递增和递减运算符

递增和递减运算符可用于迭代器，因为很多迭代器不支持算数运算。

> 除非必要，否则不使用递增递减运算符的后置版本：前置版本的递增递减运算符避免了不需要的工作，不用像后置版本将原始值存储下来以便于返回未修改的内容。当不需要修改之前的内容时，使用后置版本是一种浪费。特别是对于相对复杂的迭代器来说需要更多的工作。
> 

```python
//使用后置的递增运算符来控制循环输出vector对象内容直到遇到第一个负值为止
auto pbeg=v.begin();
while(pbeg!=v.end() && *pbeg >= 0){
	cout<<*pbeg++<<endl;  //推荐使用
}
```

后置递增运算符的优先级高于解引用运算符，所以*peg++等价于*(pbeg++)。pbeg++把pbeg的值+1，然后返回未修改的值作为求值结果，此时解引用运算符的运算对象是pbeg未增加之前的值。

**运算对象可按任意顺序求值**：

```python
while(beg!=s.end() && !isspace(*beg)){
	*beg=toupper(*beg++);
}
```

上述语句将产生未定义的行为。赋值运算符两侧都用到了beg,并且右侧对象改变了beg的值，所以该赋值语句是未定义的。

```python
*beg=toupper(*beg);  //先求左侧
*(beg+1)=toupper(*beg);  //先求右侧
```

```python
练习题：
假设ptr是指向int的指针，vec的类型是vector<int>,ival的类型是int，说一以下表
达式是何意？若表达式不正确，该如何修改？
1.ptr!=0 && *ptr++:检查ptr是否为空指针后检查ptr指向的下一个内存空间是否有值
2.ival++ && ival:检查ival和ival+1是否为0
3.vec[ival++] <= vec[ival]:无法判断vec[ival++]和vec[ival]哪一个先计算，所以结果是未定义的
```

## 4.6 成员访问运算符

ptr→mem等价于(*ptr).mem;

```python
string s1="a string",*p=&s1;
auto n=s1.size();
n=(*p).size();  //因为解引用运算符的优先级低于点运算符，所以执行解引用的子表达式两端必须加上括号
*p.size();  //错误，p为一个指针，没有size()成员
n=p->size();

```

箭头运算符作用域一个指针类型的运算对象，结果是一个左值。

点运算符有两种情况：若成员所属的对象是左值，则结果为左值；若成员所属的对象是右值，则结果为右值。

## 4.7 条件运算符

```python
string finalgrade = (grade<60) ? "fail" : "pass";
```

条件运算符的两个表达式都是左值或者能转换成同一种左值时，运算的结果是左值，否则运算的结果是右值。

**嵌套条件运算符**：

```python
//使用嵌套条件运算符将成绩分成三档：优秀（high pass），合格（pass），不合格（fail）:
string finalgrade = (grade > 90) ? "high pass"  
																 :  (grade<60) ? "fail" : "pass";
```

条件运算符满足右结合律，运算对象一般按照从右到左的顺序组合；

条件运算符的嵌套最好不超过两到三层。

**在输出表达式中使用条件运算符**：条件表达式的运算优先级非常低，因此当使用一条长表达式中嵌套了条件运算表达式时，通常需要加上括号。

```python
cout<<((grade<60)? "fail" : "pass");
cout<< (grade<60) ? "fail" : "pass";  //输出1或0；
//等价于:
cout<<(grade<60);
cout ? "fail":"pass";
cout<< grade < 60 ? "fail" : "pass"; //错误，比较了cout和60；
//等价于：
 cout<<grade;
cout<60 ? "fail" : "pass";
```

```python
练习题：
//使用嵌套条件运算符将成绩分成三档：优秀（high pass），合格（pass），不合格（fail）:
string finalgrade = (grade > 90) ? "high pass"  
																 :  (grade<60) ? "fail" : "pass";
该式成立的条件是右结合性，若条件运算符满足左结合性则求值过程如何？
答案：若为左结合性，则表达式为：
string finalgrade = ((grade > 90) ? "high pass" : (grade < 60) ? "fail":"pass";)
当grade>90时，第一个条件运算符的结果为"high pass"，最后finalgrade的结果总为fail。
```

## 4.8 位运算符

位运算符作用于整数类型的运算对象。bitset的标准库也可以表示任意大小的二进制位集合。

| ~ | 位求反 |
| --- | --- |
| << | 左移 |
| >> | 右移 |
| & | 位与 |
| ^ | 位异或 |
| | | 位或 |

一般来说，若运算对象是小整形，则值会被自动提升为较大的整数类型。运算对象可以是带符号的，也可以为无符号的。若运算对象是带符号且值为负，则位运算符是如何处理对象的符号位取决于机器。且左移操作可能会改变符号位的值，因此是一种未定义的行为。

> 关于处理符号位没有明确规定，但建议仅将位运算用于处理无符号类型。
> 

**移位运算符**：左移运算符往右侧插入值为0的二进制位。右移运算符的行为依赖于左侧运算对象的类型：若该对象位无符号类型，则左侧插入值为0的二进制位，若对象为带符号类型，则往左侧插入符号位的副本或值为0的二进制位，具体取决于环境。

**位求反运算符**：

```python
unsigned char bits=0227;  //10010111
~bits; //11111111  11111111 11111111 01101000
```

char类型运算对象首先被提升位int类型，提升时保持原来的位不变，往高位加0，本例中往高位添加了24个0，随后逐位求反。

**位于、位或、位异或运算符**：位与（若两个对象都为1时才为1，否则为0），为或（只要有一个对象为1时，就可为1，否则为0），为异或（两个对象相异为1，相同为0）。

**使用运算符**：假设有30个学生，老师对学生进行测验，结果为通过和不通过两种，使用无符号数表示全班的测试结果：

```python
unsigned long quiz1=0;  //定义为unsigned long确保在每台机器上都至少有32位
```

教师检查每一个二进制位，假设27号学生通过的测试，则生成一个值表示27号学生通过了测试：

```python
1UL << 27;  
```

将所得的值和quiz1进行或运算，表示27号学生通过了测验：

```python
quiz1 |= 1UL << 27;
```

假设教师在核验时发现27号学生没有通过测试，则将27位置0：

```python
quiz1 &= ~(1UL<<27)  //27号学生没有通过测验
```

最后检查27号学生是否通过测验：

```python
bool status = quiz1 & (1UL<<27);
```

**移位运算符满座左结合律**：移位运算符的优先级不高不低，比算数运算符的优先级低，但比关系运算符、赋值运算符、条件运算符的优先级高。在必要时要加上括号。

```python
cout<<42+10;  //正确
cout<<(10<42);  //正确
cout<<10<42;  //错误，试图比较cout和42，(cout<<10) < 42
```

## 4.9 sizeof运算符

sizeof运算符返回一条表达式或者一个类型名字所占的字节数。sizeof运算符满足右结合律，所得的值是一个size_t类型。运算符的对象有两种形式：

```python
sizeof(type);
sizeof expr; //该形式中，sizeof返回的是表达式结果类型的大小，sizeof不计算实际运算对象的值
```

```python
Sale_data data,*p;
sizeof(Sale_data);  //存储Sale_data类型对象所占的大小
sizeof data;  //data类型所占的大小
sizeof p;  //指针所占的空间大小
sizeof *p;  //p所指的空间的大小
sizeof data.revenue;  //revenue成员对应的大小
sizeof Sale_data::revenue;  //revenue成员对应的大小
```

因为sizeof不会实际求运算对象的值，所以即使p为一个无效的指针也不会有影响。

sizeof运算符无须提供一个具体的对象，就可以访问到成员的大小。

sizeof运算符的结果依赖于作用的类型：

1.对char或类型为char的表达式执行sizeof运算符，结果为1；

2.对引用类型执行sizeof运算符得到被引用对象所占空间的大小。

3.对指针进行sizeof运算得到指针所占空间的大小。

4.对解引用指针执行sizeof运算得到指针指向的对象的空间大小，指针不需要有效。

5.对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有元素执行依次sizeof运算得到的结果之和。sizeof运算不会把数组转换成指针处理。

6.对string对象或vector对象执行sizeof运算值返回该类型固定部分的大小，不会计算对象中元素占了多少空间。

```python
//用数组大小除以单个元素的大小得到数组中元素的个数
int ia[10];
constexpr size_t sz=sizeof(ia)/sizeof(*ia);   //*ia=ia[0];
int arr2[sz];
```

```python
练习题：
1.判断下列的运算结果：
int x[10];
int *p=x;
cout<<sizeof(x)/sizeof(*x)<<endl;  //sizeof(x)=40,sizeof(*x)=sizeof(a[0])=4,结果为10
cout<<sizeof(p)/sizeof(*p)<<endl;  //sizeof(p)=4或8，sizeof(*p)=4,返回指针p所占类型所占的字节数。
```

## 4.10 逗号运算符

逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。逗号运算符也规定了运算对象求值的顺序。

```python
vector<int>::size_type cnt=ivec.size();
for(vector<int>::size_type ix=0; ix!=ivec.size(); ++ix,--cnt)
	ivec[ix]=cnt;
```

```python
练习题：
说明下来表达式的含义：someValue ? ++x,++y : --x,--y
等价于(someValue ? ++x,++y : --x),--y;
```

## 4.11 类型转换

隐示转换：当将两个不同类型的值相加时，程序自动根据转换规则将运算对象的类型统一后再求值。

发生隐式转换的情况：

- 在大多表达式中，比int小的整型会提升为较大的整数类型；
- 在条件中，非布尔值转换为布尔值；
- 初始化过程中，初始值转换为变量的类型；赋值语句中，右侧对象转换为左侧运算对象的类型；
- 若算数运算或关系运算对象有多种类型，需要转换为同一类型；
- 函数调用时也会发生类型转换；

### 4.11.1 算数转换

**整型提升**：把小整数转换成大的整数类型。对于bool、char、signed char、unsigned char、short、unsigned short等类型会提升为int类型；否则提升为unsigned int。布尔值false提升为0、true提升为1。较大的char类型（wchar_t,char16_t,char32_t）提升为int, unsigned int, long, unsigned long, long long, unsigned long long中最小的一种类型。

无符号类型的运算对象：当两个不同类型的运算对象相加，若其中一个为无符号类型，那么转换的结果依赖于机器中整数类型的大小。

首先进行整型提升，提升后的对象都为无符号或都为带符号的类型，将小类型的运算对象转换为较大的类型。

若其中一个运算对象是无符号，另外一个运算对象是带符号的。当无符号类型≥带符号类型，则将带符号类型转换为无符号类型。如，unsigned int和int运算，将int转换为unsigned int。当无符号类型≤带符号类型时，转换结果取决于机器。若无符号类型的所有值都能存储在带符号类型中，则转换为带符号类型，若不能则转换为无符号类型。如，long和unsigned int运算，若int和long大小相同，则long类型转换为unsigned int类型，若long占的空间大于int，则将unsigned int转换为long。

**理解算数转换**：

```python
bool flag;
char cval;
short sval;
unsigned short usval;
int ival;
unsigned int uival;
long lval;
unsigned long ulval;
float fval;
double dval;

3.1415L+'a';  //'a'提升为int，然后int转换为long double
dval+ival;  //ival转换为double
dval+fval;  //fval转换为double
ival=dval;  //dval转换为int
flag=dval;  //若dval为0转换为false,否则转换为true
cval+fval;  //cval转换为int，后int转换为float
sval+cval;  //sval和cval都转换为int
cval+lval;  //cval转换为long
ival+ulval;  //ival转换为unsigned long
usval+ival;  //根据unsigend short和int所占的空间进行提升
uival+lval;  //更具unsigned int和long所占的空间进行提升
```

### 4.11.2 其他隐式类型转换

**数组转换为指针**：在大多数用到数组的表达式中，数组自动转换为指向数组首元素的指针。

```python
int ia[10];
int *ip=ia;  //ia转换为指向数组首元素的指针
```

当数组被用作decltype关键字的参数、取地址符（&）、sizeof、typeid？？等运算符的对象时，上述转换不会发生。若用一个引用来初始化数组时，上述转换也不会发生？？。在表达式中使用函数类型时会发生类似的指针转换。

**指针的转换**：常量整数值0或者字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换为void*；指向任意对象的指针能转换为const void*；在有继承关系的类型见还有一种指针转换的方式。

**转换成布尔类型**：若指针或算数类型的值为0，转换结果为false，否则为true。

```python
char *cp=get_string();
if(cp) /*...*/  //若指针非0,条件为真
while(*cp) /*...*/  //若*cp不为空字符，条件为真
```

**转换为常量**：允许将指向非常量类型的指针转换成指向相应常量类型的指针。即若T为一种类型，则可以将指向T的指针或引用分别转换为指向const T的指针或引用。但相反的转换并不存在，因为其试图删除底层const。

```python
int i;
const int &j=i;  //非常量转换为const int的引用
const int *p=&i;  //非常量的地址转换为const的地址
int &r=j,*q=p;  //错误，不允许const转换为非常量
```

**类类型定义的转换**：类类型能定义由编译器自动执行的转换，不过编译器每次只执行一种类型转换。

如，在需要标准库string类型的地方使用C风格字符串。或在条件部分读入istream。

```python
string s,t="a value";   //将字面值转换为string类型
while(cin >> s)  //将cin转换为布尔值
```

cin>>s的条件部分需要一个布尔值。IO库定义了从istream向布尔值的转化，根据这个规则将cin自动转换为布尔值。所得到的布尔值是由输入流的状态决定的，若最后一次读入成功，得到的布尔值为true，否则最后一次读入不成功，转换得到的布尔值为false。

### 4.11.3 显示转换

强制类型转换：显式的将对象强制转换为另一种类型。

> 虽然有时候不得不使用强制类型转换，但这种方法本质上是十分危险的，要避免使用强制类型转换。
> 

强制类型转换的形式：

```python
cast-name<type>(expression);
//type:目标类型，若为引用类型，则转换的结果为左值
//expression:要转换的值
//cast-name:static_cast, dynamic_cast, const_cast,reinterpret_cast四种。dynamic_cast支持
运行时识别，在后续讨论。
```

**static_cast**：任何有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。如，将一个运算对象强制转换为double类型使表达式可以执行浮点数运算。

```python
double slope=static_cast<double>(j)/i;
```

当需要把一个较大的算术类型赋给较小的类型时，static_cast非常有用。强制类型转换告诉编译器不在乎精度损失。当编译器发现将一个较大的算数类型赋给较小的类型，就会发出警告。但是当执行显式类型转换后，警告就会关闭。

static_cast对于编译器无法自动执行的类型转换也非常有用。如，使用static_cast找回存在于void*的指针中的值

```python
void *p=&d;
double *dp=static_cast<double>(p);
```

当将指针放在void*中，并使用static_cast将其强制转换为原来的类型时，确保强制转换的结果和原始的类型相等，否则产生未定义的行为。

**const_cast**：const_cast只改变对象的底层const;

```python
const char *pc;
char *p=const_cast<char*>(pc);  //正确，但通过p写值是未定义的行为
```

一旦去掉某个对象的const性质，编译器就不再组织我们对该对象进行写操作了。若对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。若对象是一个常量，使用const_cast执行写操作会产生未定义的结果。

只有const_cast能改变表达式的常量属性，其他形式的命名强制类型转换改变表达式的常量属性都会引发编译器的错误。同样不能用const_cast改变表达式的类型。

```python
const char *cp;
char *q=static_cast<char*>(cp);  //错误，static_cast无法去掉const性质
static_cast<string>(cp);  //正确，将字符串字面量转换为string类型
const_cast<string>(cp);  //错误，const_cast只改变常量属性，不改变类型
```

const_cast常常用于有函数重载的上下文中。

**reinterpret_cast**：reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。

```python
int *ip;
char *pc=reinterpret_cast<char*>(ip);
//pc所指的对象是一个int而非字符，若将pc当成普通字符指针使用在运行时会发生错误，如：
string str(pc);   //可能导致运行时出错
```

## 4.12 运算优先级表

![1.PNG](%E7%AC%AC4%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%20d932b5ac291647e5a5daab6708b4e40e/1.png)

![2.PNG](%E7%AC%AC4%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%20d932b5ac291647e5a5daab6708b4e40e/2.png)